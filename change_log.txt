Detailed record of changes and validation steps
===============================================

Source adjustments
-----------------

1. `signature_plots/trueOG.cpp`
   - Added POSIX-compatible shims for MSVC-only helpers (`fopen_s`, `sprintf_s`, `strncpy_s`) under `#ifndef _MSC_VER`.
   - Introduced aliases for `errno_t`, safe copy semantics, and buffer bounds checking to match MSVC behaviour.
   - Updated default arguments to target `qut3.fasta` with `PARTITION_SIZE = 2048` and enabled CLI overrides for both parameters.
   - Left the hashing, partition, and I/O loops unchanged to preserve the original algorithm (including the EOF record behaviour).
   - Added a CLI usage guard that expects `<num_threads>` (validated but ignored) so the entry point matches the VS profiling harness.

2. `compare_signatures.py`
   - New Python utility that:
     * Reads signature binaries (document id + 8-byte signature records).
     * Computes Hamming distances, document-id mismatches, and summary stats.
     * Emits histogram and line plots for the first N records, saved to a configurable output directory.
   - Accepts options for sample size and maximum records, making it reusable across datasets.

3. `change_log.txt`
   - Tracks every modification, dataset transformation, comparison, and timing benchmark from this session.


Data preparation
----------------

4. Created `qut3_unix.fasta` by replacing CRLF (`\r\n`) line endings with LF (`\n`), ensuring all implementations hash identical byte sequences.
   - Rationale: the legacy single-thread reader hashed raw carriage returns, leading to mismatches; normalising line endings removes this artefact without altering biological content.


Build artefacts
---------------

5. Compiled executables (all with ISAAC RNG linked):
   - `trueOG_ref` from `signature_plots/trueOG.cpp`.
   - `signature_stdthread_new` from `signature_stdthread.cpp`.
   - `signature_omp_ref` from `signature.cpp` with `-fopenmp`.


Correctness verification
------------------------

6. Generated signature binaries on both the original CRLF FASTA and the normalised Unix FASTA, capturing outputs per implementation:
   - `trueOG_qut3.bin`, `stdthread_qut3.bin`, `omp_qut3.bin`.
   - Additional variants for raw CRLF runs kept for comparison (`trueOG_output.bin`, etc.).

7. Used `compare_signatures.py` to validate bit-for-bit agreement:
   - `trueOG` vs `stdthread`: 200 000 matching records; only difference is the legacy extra trailing record (12 bytes).
   - `stdthread` vs `omp`: complete agreement across all records.
   - `trueOG` vs `omp`: same findings as `trueOG` vs `stdthread`.
   - Plots saved under:
     * `signature_plots/trueOG_vs_std/`
     * `signature_plots/std_vs_omp/`
     * `signature_plots/trueOG_vs_omp/`
   - Histogram and sequence plots document zero Hamming distances and identical doc ordering.

8. Confirmed document coverage via Python inspection:
   - `stdthread` and `omp` output docs 0–199 999.
   - `trueOG` outputs the same range plus doc 200000 because of the `while (!feof)` loop.


Performance benchmarking
------------------------

9. Timed each executable on `qut3_unix.fasta` (PARTITION_SIZE 2048):
   - `trueOG_ref` (single-thread) ≈ 11.5 s average across three runs.
   - `signature_stdthread_new` with 8 threads ≈ 1.0 s.
   - `signature_omp_ref` with `OMP_NUM_THREADS=8` ≈ 0.98 s.
   - Demonstrated ~11× speedup for multi-threaded versions while maintaining identical outputs.


Auxiliary outputs and files
---------------------------

10. Temporary binaries copied for analysis (`*_qut3.bin`, `*_output.bin`, plots) are retained in the workspace for reporting. They can be regenerated by re-running the documented commands if needed.
11. No destructive Git operations performed; all changes are additive or compatibility-focused.

Visual Studio specific variants
-------------------------------

12. Added `signature_stdthread_vs.cpp`, `signature_omp_vs.cpp`, and `signature_plots/trueOG_vs.cpp` for Visual Studio profiling workflows (all expect `<num_threads> [input_fasta]`).
    - Each expects `<num_threads>` as the first CLI argument (with optional input file), matching the Python performance wrapper interface.
    - The std::thread version caps requested threads to the available hardware and reuses the existing processing pipeline.
    - The OpenMP version invokes `omp_set_num_threads(num_threads)` before the parallel loop.
    - The legacy OG variant retains MSVC-specific helpers (`fopen_s`, `sprintf_s`, `strncpy_s`) without the POSIX shims used in the cross-platform build, while still normalising CRLF input lines.

13. Documented optimisation journey and difficulties:
    - Converting the OG hash-table build into the optimised single-thread baseline required replacing uthash lookups with the indexed vocabulary array while preserving exact RNG behaviour; several profiling runs verified parity and exposed the queue-based experiments that regressed cache locality.
    - Porting the VS harness demanded care around safe CRT calls (`sprintf_s`, `fopen_s`) and dummy CLI threading guards so tooling continued to function during profiler captures.
    - Threading with `std::thread` introduced challenges around work partitioning, avoiding contention, and maintaining deterministic output ordering; the final contiguous block scheduling replaced an earlier task-queue design that suffered mutex bottlenecks.
    - The OpenMP path required tuning of scheduling strategies (dynamic vs static) and avoiding overzealous parallel I/O that triggered critical-section hot spots; detailed profiling confirmed the chosen configuration balanced load without regressing throughput.

14. Optimised serial computation further:
    - Replaced dense 64-slot signature updates with a sparse representation (store only non-zero indices/values) and rewrote the accumulation loop to iterate ~13 entries per k-mer instead of 64.
    - Dropped the now-unused dense vocabulary store, keeping a lightweight `SparseTerm` array shared by both portable and VS builds.
    - Achieved ~1.1–1.5 s total runtime for the single-thread baseline on `qut3_unix.fasta` (down from ~3.0 s) while preserving bit-for-bit parity with threaded/OpenMP outputs.
    - Increased `PARTITION_SIZE` to 8192, reducing per-doc overhead while keeping downstream output compatible.
    - Added a top-level program timer so reports can quote whole-of-executable runtime alongside compute-only measurements.

15. May 2026 follow-up instrumentation and parser tweaks:
    - Updated `signature_stdthread_vs.cpp` to avoid storing per-sequence `std::string`s: the FASTA file is loaded once into a contiguous buffer and each worker reconstructs a clean slice based on recorded header offsets. Maintains deterministic ordering while reducing parse overhead and halving the serialized portion to ~0.27 s (8-thread program time ≈0.55 s vs 1-thread ≈1.29 s).
    - Added whole-program timers to the Visual Studio wrapper and OpenMP portable build so compute, total (post-parse), and end-to-end timings can be compared directly for Amdahl analysis. Current OpenMP numbers: `compute ≈0.26 s`, `total ≈0.29 s`, `program ≈0.51 s` on `qut3.fasta`, implying ~51 % serial work.
    - Documented the abandoned streaming producer/consumer prototype (mutex contention drove runtime above 8 s) and kept the deterministic doc-block scheduling as the recommended approach.
